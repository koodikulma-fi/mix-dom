var e=require('dom-types'),t=require('data-signals'),n=require('data-memo');const o={boundary:!0,pass:!0,host:!0,fragment:!0};function mergeChangesTo(e,...t){for(const n of t)n&&n[0][0]&&(e[0]=e[0].concat(n[0])),n&&n[1][0]&&(e[1]=e[1].concat(n[1]))}function sortBoundaries(e){const t=new Map;for(const n of e){let e=n.bId,o=n.parentBoundary;for(;o;)e=(o.bId||'')+'>'+e,o=o.parentBoundary;const s=t.get(e);if(s){let e=0;if(n.parentBoundary){const t=n.parentBoundary.innerBoundaries,o=t.indexOf(n);for(const n of s){if(o<t.indexOf(n))break;e++}}s.splice(e,0,n)}else t.set(e,[n])}const n=[];for(const e of t.keys()){let t=0,o=!1;for(const s of n){if(s.startsWith(e+'>'))break;if(e.startsWith(s+'>'))o=!0;else if(o)break;t++}n.splice(t,0,e)}let o=0;const s=[];for(const e of n)for(const n of t.get(e))s[o++]=n;return s}function updatedInterestedInClosure(e,t=!0){let n=[[],[]];for(const o of t&&e.size>1?sortBoundaries(e):e){if(!o._forceUpdate&&!o.component.renderedState&&o.component.props===o._outerDef.props)continue;const e=o.host.services.updateBoundary(o);e&&mergeChangesTo(n,e)}return n}function collectInterestedInClosure(e,t){if(t){const e=new Set;if(t.closure.withContents)for(const n of t.closure.withContents)e.add(n);for(const n of t.constructor.WithContent.withContents)e.add(n);return e.size?e:null}if(!e.withContents&&!e.chainedClosures)return null;const n=e.withContents?new Set(e.withContents):new Set;if(e.chainedClosures)for(const t of e.chainedClosures){const e=collectInterestedInClosure(t);if(e)for(const t of e)n.add(t)}return n.size?n:null}function treeNodesWithin(e,t,n=0,o=!1,s=!1,r){const i=[];let d,a=[e],l=0;const c=e.boundary;for(;d=a[l];)if(l++,!d.boundary||null!==d.boundary.hasMounted){if((!t||t.has(d.type))&&(!r||r(d))){const e=i.push(d);if(n&&e>=n)return i}d.boundary&&!o&&d.boundary!==c||('host'!==d.type||s)&&d.children[0]&&(a=d.children.concat(a.slice(l)),l=0)}return i}function rootDOMTreeNodes(e,t=!1,n=!1,o=0){let s=[];for(const r of e.children)if(r.domNode||n)switch(r.type){case'dom':if(s.push(r),o&&s.length>=o)return s;break;case'boundary':case'pass':case'host':if(!t)break;case'root':if(s=s.concat(rootDOMTreeNodes(r,t,n,o&&o-s.length)),o&&s.length>=o)return s.slice(0,o)}return s}function allDefsIn(e,t=!1){var n,o;const s=[];let r,i=[e],d=0;for(;r=i[d++];)r.updateId&&t&&r.updateId===(null===(o=null===(n=r.treeNode)||void 0===n?void 0:n.sourceBoundary)||void 0===o?void 0:o.host.services._whileUpdating)||s.push(r),r.childDefs[0]&&(i=r.childDefs.concat(i.slice(d)),d=0);return s}function domElementByQuery(e,t,n=!1,o=!1){const s=treeNodesWithin(e,new Set(['dom']),1,n,o,(e=>e.domNode&&e.domNode instanceof Element&&e.domNode.matches(t)))[0];return s&&s.domNode||null}function domElementsByQuery(e,t,n=0,o=!1,s=!1){return treeNodesWithin(e,new Set(['dom']),n,o,s,(e=>e.domNode&&e.domNode instanceof Element&&e.domNode.matches(t))).map((e=>e.domNode))}var __rest=function(e,t){var n={};for(var o in e)Object.prototype.hasOwnProperty.call(e,o)&&t.indexOf(o)<0&&(n[o]=e[o]);if(null!=e&&'function'==typeof Object.getOwnPropertySymbols){var s=0;for(o=Object.getOwnPropertySymbols(e);s<o.length;s++)t.indexOf(o[s])<0&&Object.prototype.propertyIsEnumerable.call(e,o[s])&&(n[o[s]]=e[o[s]])}return n};const s={};function newDef(t,n=null,...o){const s=function parseDefType(e){if('string'==typeof e)return'_'===e?'element':'dom';if(!e)return'';const t=e.MIX_DOM_CLASS;if(!t)return'function'==typeof e?e.length>=2?'boundary':'spread':'';switch(t){case'Component':case'Remote':return'boundary';case'Fragment':case'Portal':case'Element':case'Host':return t.toLowerCase();default:return''}}(t);if(!s||n&&n._disable)return null;const r=[];let i=!1,d=0;for(const e of o){let t='string'==typeof e;if(e&&t&&i){r[d-1].domContent+=e;continue}const n=newDefFrom(e);n&&(d=r.push(n),i=t)}if('spread'===s)return function unfoldSpread(e,t,n){var o;const{_key:s,_disable:r}=t,i=__rest(t,['_key','_disable']);let d=newDefFrom(e(i));if(!d)return null;const a={passes:[],withs:[]},l={MIX_DOM_DEF:'fragment',childDefs:[Object.assign({},d)],scopeType:'spread',spreadLinks:a,tag:null};null!=s&&(l.key=s);null!=r&&(l.disabled=r);let c,u=[l],p=!1,f=0;const h=!!n[0];for(;c=u[f];){if(f++,!c.childDefs[0])continue;let e=[];const t=c.childDefs;c.childDefs=[];for(const s of t){let t;if(s.spreadLinks){t=s,e=e.concat(s.spreadLinks.passes);for(const[e,t]of s.spreadLinks.withs){const n=e&&hasContentInDefs(e,h);'maybe'!==n&&(t.props.hasContent=n),'maybe'===n&&a.withs.push([e,t])}}else if('pass'===s.MIX_DOM_DEF)s.getRemote?t=s:(t={MIX_DOM_DEF:'fragment',tag:null,childDefs:[...n]},null!=s.key&&(t.key=s.key),p||'copy'===s.contentPassType?t.scopeType='spread-copy':(t.scopeType='spread-pass',p=!0),a.passes.push(t));else if(t=Object.assign({},s),e.push(t),'boundary'===s.MIX_DOM_DEF&&s.tag._WithContent&&!s.tag._WithContent.getRemote&&!s.tag.withContents&&null==(null===(o=t.props)||void 0===o?void 0:o.hasContent)){const e=hasContentInDefs(n,h);t.props=Object.assign({hasContent:'maybe'===e?void 0:e},t.props),'maybe'===e&&a.withs.push([n,t])}c.childDefs.push(t)}u=e.concat(u.slice(f)),f=0}return l}(t,n||{},r);if('fragment'===s&&!r[0])return null;const a='dom'===s&&t||'boundary'===s&&t||'element'===s&&'_'||('content'===s?'':null),l={MIX_DOM_DEF:s,tag:a,childDefs:r};if('fragment'===l.MIX_DOM_DEF);else if(n){const{_key:t,_ref:o,_signals:r,_contexts:i,_disable:d}=n,c=__rest(n,['_key','_ref','_signals','_contexts','_disable']);if(null!=t&&(l.key=t),o){const e=[];if('Ref'===o.constructor.MIX_DOM_CLASS)e.push(o);else for(const t of o)t&&'Ref'===t.constructor.MIX_DOM_CLASS&&-1===e.indexOf(t)&&e.push(t);l.attachedRefs=e}r&&(l.attachedSignals=Object.assign({},r)),i&&'boundary'===s&&(l.attachedContexts=Object.assign({},i)),a&&(l.props='string'==typeof a&&'_'!==a?e.cleanDOMProps(c):c)}else a&&(l.props={});switch(l.MIX_DOM_DEF){case'portal':l.domPortal=n.container||null;break;case'element':{const t=l.props||{},{element:n,cloneMode:o}=t,s=__rest(t,['element','cloneMode']);l.props=e.cleanDOMProps(s),l.domElement=n||null,l.domCloneMode=null!=o?'boolean'==typeof o?o?'deep':'':o:null;break}}return l}function newDefFrom(e){if(e&&'object'==typeof e){if('string'==typeof e.MIX_DOM_DEF)return e;if(e instanceof Node)return{MIX_DOM_DEF:'content',tag:'',childDefs:[],domContent:e};if('Host'===e.constructor.MIX_DOM_CLASS)return{MIX_DOM_DEF:'host',tag:null,host:e,key:e,childDefs:[]};if(Array.isArray(e)||e instanceof HTMLCollection||e instanceof NodeList){const t=[...e].map((e=>newDefFrom(e))).filter((e=>e));return t.length?{MIX_DOM_DEF:'fragment',tag:null,isArray:!0,childDefs:t}:null}e=String(e)}return null!=e?{MIX_DOM_DEF:'content',tag:'',domContent:e,childDefs:[]}:null}function newAppliedDef(e,t){const n={MIX_DOM_DEF:e.MIX_DOM_DEF,tag:e.tag,childDefs:[],action:'mounted'};return null!=e.key&&(n.key=e.key),'fragment'===n.MIX_DOM_DEF?(e.isArray&&(n.isArray=!0),e.scopeType&&(n.scopeType=e.scopeType)):'pass'===n.MIX_DOM_DEF?e.getRemote?(n.getRemote=e.getRemote,n.contentPass=e.contentPass||null):n.contentPass=e.contentPass||t||null:e.host&&(n.host=e.host),n}function newContentPassDef(e,t){const n={MIX_DOM_DEF:'pass',tag:null,childDefs:[],contentPassType:t?'copy':'pass'};return null!=e?n.key=e:t||(n.key=s),n}const checkRecursively$1=e=>e.contentPass&&e.contentPass.envelope&&hasContentInDefs(e.contentPass.envelope.applied.childDefs,checkRecursively$1)||!1;function hasContentInDefs(e,t=checkRecursively$1){let n=!1;for(const o of e){if(o.disabled)continue;const e='fragment'===o.MIX_DOM_DEF?hasContentInDefs(o.childDefs,t):'pass'!==o.MIX_DOM_DEF||('function'==typeof t?t(o):t&&'maybe');if(e){if(!0===e)return!0;n=!0}}return n&&'maybe'}const r=newContentPassDef(),i=newContentPassDef({},!0);class Ref extends t.SignalBoy{constructor(...e){super(...e),this.treeNodes=new Set}getTreeNode(){return[...this.treeNodes][this.treeNodes.size-1]||null}getTreeNodes(){return[...this.treeNodes]}getElement(e=!1){let t=this.treeNodes.size-1;const n=[...this.treeNodes];for(;t>=0;){const o=n[t--];if(o.domNode&&(!e||'dom'===o.type))return o.domNode}return null}getElements(e=!1){let t=[];for(const n of this.treeNodes)n.domNode&&('dom'===n.type?t.push(n.domNode):e||(t=t.concat(rootDOMTreeNodes(n,!0).map((e=>e.domNode)))));return t}getComponent(){var e;const t=[...this.treeNodes][this.treeNodes.size-1];return t&&'boundary'===t.type&&(null===(e=t.boundary)||void 0===e?void 0:e.component)||null}getComponents(){var e;const t=[];for(const n of this.treeNodes)'boundary'===n.type&&(null===(e=n.boundary)||void 0===e?void 0:e.component)&&t.push(n.boundary.component);return t}static onListener(e,t,n,o){if(e.treeNodes.size&&e.signals[t]){const s=e.signals[t][n],r=s[0];if(o)for(const n of e.getComponents())n.listenTo(t,((...e)=>s[1]?r(n,...e,...s[1]):r(n,...e)),null,s[2],r);else for(const n of e.getComponents())n.unlistenTo(t,r)}}static didAttachOn(e,n){var o;if(!e.treeNodes.has(n))if(e.treeNodes.add(n),'boundary'===n.type){const s=null===(o=n.boundary)||void 0===o?void 0:o.component;for(const t in e.signals)for(const n of e.signals[t]){const[e,o,r]=n;s.listenTo(t,((...t)=>o?e(s,...t,...o):e(s,...t)),null,r,e)}s&&e.signals.didAttach&&t.callListeners(e.signals.didAttach,[s])}else'dom'===n.type&&n.domNode&&e.signals.domDidAttach&&t.callListeners(e.signals.domDidAttach,[n.domNode])}static willDetachFrom(e,n){var o;if(e.treeNodes.has(n))if('boundary'===n.type){const s=null===(o=n.boundary)||void 0===o?void 0:o.component;if(s){e.signals.willDetach&&t.callListeners(e.signals.willDetach,[s]);for(const t in e.signals)for(const n of e.signals[t])s.unlistenTo(t,n[0])}}else'dom'===n.type&&n.domNode&&e.signals.domWillDetach&&t.callListeners(e.signals.domWillDetach,[n.domNode]);e.treeNodes.delete(n)}}Ref.MIX_DOM_CLASS='Ref';class HostRender{constructor(e,t){this.assimilationRoot=t||null,this.paused=e.disableRendering,this.settings=e,this.externalElements=new Set,this.inBrowser='object'==typeof document}pause(){this.paused=!0}resume(){this.paused&&(this.paused=!1,this.assimilationRoot&&this.reassimilate(null,!0))}reassimilate(t=null,n=!1,o=!1,s=!1,r,i){var d;const a=this.assimilationRoot;if(!a)return void(this.settings.debugMode&&console.warn('__HostRender.reassimilate: Warning: No assimilation root assigned. ',this));const l=t?HostRender.createVirtualItemsFor(t):{};l.validator=r,l.suggester=i;const c=l.reused=new Set(t?[...this.externalElements,t]:this.externalElements),u=[];for(const[t,,s]of HostRender.getVirtualDomPairs(a,l,!1)){let r=t.domNode;!s||t.domNode&&!o||(r=s),r&&c.add(r);const i={treeNode:t};let d=n;if(r!==t.domNode&&(d=!0,t.domNode?r&&(i.swap=r):i.create=!0),!i.create&&r){const[n,o]=HostRender.findInsertionNodes(t);r.parentNode===n&&r.nextSibling===o||(i.move=!0),'content'===t.def.MIX_DOM_DEF?i.content=!0:(d&&(t.domProps=e.readDOMProps(r)),i.update=!0)}(i.create||i.swap||i.move||i.update||i.content)&&u.push(i)}if(s&&t){let e,n=t===a.domNode?rootDOMTreeNodes(a.children[0],!0).map((e=>e.domNode)).filter((e=>e)):[...t.childNodes],o=0;for(;e=n[o];)o++,c.has(e)?e.childNodes[0]&&(n=[...e.childNodes,...n.slice(o)],o=0):null===(d=e.parentNode)||void 0===d||d.removeChild(e)}if(this.settings.disableRendering||(this.paused=!1),u[0]&&this.applyToDOM(u),this.pausedPending){const e=this.pausedPending.filter((e=>e.treeNode.domNode&&!c.has(e.treeNode.domNode)));delete this.pausedPending,e[0]&&this.applyToDOM(e)}}applyToDOM(n){var o;const s=this.sourceRemount;if(s&&this.assimilationRoot&&HostRender.onRemount(s,this.assimilationRoot),this.paused){const e=n.filter((e=>e.remove));return void(e[0]&&(this.pausedPending=(this.pausedPending||[]).concat(e)))}const r=this.settings;let i=null,d=null,a=null,l=null;for(const c of n){const n=c.treeNode,u=n.def.attachedSignals,p=n.def.attachedRefs;if(c.remove){if('dom'===n.type&&n.domNode){const e=n.domNode,o=e.parentNode;let s=!1;if((null==u?void 0:u.domWillUnmount)&&u.domWillUnmount(e)&&(s=!0),p)for(const o of p)o.signals.domWillUnmount&&t.askListeners(o.signals.domWillUnmount,[e],['no-false','last'])&&(s=!0),Ref.willDetachFrom(o,n);s?a?a.push(e):a=[e]:!o||d&&-1!==d.indexOf(o)||a&&a.some((t=>t.contains(e)))||o.removeChild(e);const r='element'===n.def.MIX_DOM_DEF;(r||'content'===n.def.MIX_DOM_DEF)&&this.externalElements.delete(e),r||(d||(d=[])).push(e),n.domNode=null,HostRender.updateDOMChainBy(n,null)}continue}let f=!1,h=0;if(c.refresh&&n.domNode&&n.domProps&&(n.domProps='read'===c.refresh?e.readDOMProps(n.domNode):{},f=!0),c.create)if(n.domNode)h=!s||n.domNode.nodeType!==Node.TEXT_NODE||!0!==s.readFromDOM&&'content'!==s.readFromDOM?2:3;else switch(n.type){case'dom':const e=this.createDOMNodeBy(n);e&&(n.domNode=e,h=1,s&&s.created&&s.created.add(e));break;case'portal':n.domNode=n.def.domPortal||null}if(h||c.move)if('host'===n.type){const e=n.def.host||null;e&&e.services.refreshRoot(!1,null,null),n.domNode=n.parent&&e&&e.getRootElement()||null,HostRender.updateDOMChainBy(n,n.domNode)}else n.domNode&&(h<2||!n.domNode.parentElement?(i||(i=[])).push(c):((n.def.attachedRefs||n.def.attachedSignals)&&(l||(l=[])).push([!0,c.treeNode,n.domNode.parentElement,n.domNode.nextSibling]),HostRender.updateDOMChainBy(n,n.domNode)));if(c.swap){const t=!0!==c.swap,s=n.domNode;let i=t?c.swap:('portal'===n.type?n.def.domPortal:n.def.domElement)||null;if(s!==i){if(!t&&'dom'===n.type){const t=n,d=s&&s.parentNode;if(i&&(i=this.getApprovedNode(i,t),i)){let[e,t]=d?[d,s]:HostRender.findInsertionNodes(n);e&&e.insertBefore(i,t)}if(s){if(this.externalElements.delete(s),(null===(o=t.domProps)||void 0===o?void 0:o.listeners)&&s instanceof Element){const e=t.domProps.listeners;for(const t in e)e[t]&&s.removeEventListener(t,e[t])}d&&d.removeChild(s)}t.domProps&&(t.domProps=i&&'read'===r.renderDOMPropsOnSwap?e.readDOMProps(i):{},f=!0)}for(const e of n.children){const t=e.domNode;t&&(t.parentNode&&t.parentNode.removeChild(t),i&&i.appendChild(t))}n.domNode=i,HostRender.updateDOMChainBy(n,i)}}if((c.content||3===h)&&'dom'===n.type&&n.domNode){const e=n.def.domContent,o=n.domNode;let s=o;if('content'===n.def.MIX_DOM_DEF){if(n.def.domHTMLMode)s=null!=e&&''!==e?HostRender.domNodeFrom(e.toString(),n.def.tag||r.renderHTMLDefTag,!0,r.renderInnerHTML,n):null,s&&n.domProps&&(f=!0,n.domProps={});else{const t=null==e?'':(r.renderTextHandler?r.renderTextHandler(e):e).toString();o.nodeType!==Node.TEXT_NODE&&this.inBrowser?s=document.createTextNode(t):o.textContent=t}}else if(e instanceof Node){const t=e.parentNode;t&&t.removeChild(e)}else o.textContent='';if(s&&o!==s){const e=o.parentNode;e&&(n.domNode=s,e.insertBefore(s,o),e.removeChild(o)),HostRender.updateDOMChainBy(n,n.domNode)}if((null==u?void 0:u.domDidContent)&&u.domDidContent(n.domNode,null!=e?e:null),p)for(const o of p)o.signals.domDidContent&&t.callListeners(o.signals.domDidContent,[n.domNode,null!=e?e:null])}if((h||f||c.update)&&'dom'===n.type){const o=n.domNode instanceof Element?n.domNode:null,s=n.def.props||{},i=e.applyDOMProps(n.domNode instanceof Element?n.domNode:null,s,n.domProps||{},r.debugMode);if(n.domProps=s,i&&c.update&&o&&((null==u?void 0:u.domDidUpdate)&&u.domDidUpdate(o,i),p))for(const e of p)e.signals.domDidUpdate&&t.callListeners(e.signals.domDidUpdate,[o,i])}c.emptyMove&&HostRender.updateDOMChainBy(n,null,!0)}if(i){const e=[];let t=i.length;for(;t--;){const n=i[t],o=n.treeNode,s=o.domNode;if(s){const t=s.parentNode,r=s.nextSibling,[i,d]=s?HostRender.findInsertionNodes(o):[null,null];i===t&&d===r||(i&&e.push([s,i,d]),(o.def.attachedRefs||o.def.attachedSignals)&&(l||(l=[])).push([!n.move,n.treeNode,t,r]),t&&t.removeChild(s))}HostRender.updateDOMChainBy(o,s)}if(e[0])for(const t of e)t[1].insertBefore(t[0],t[2])}if(l){let e=l.length;for(;e--;){const[n,o,s,r]=l[e],{attachedSignals:i,attachedRefs:d}=o.def,a=o.domNode;if(i&&(n?i.domDidMount&&i.domDidMount(a):i.domDidMove&&i.domDidMove(a,s,r)),d)for(const e of d)n?(Ref.didAttachOn(e,o),e.signals.domDidMount&&t.callListeners(e.signals.domDidMount,[a])):e.signals.domDidMove&&t.callListeners(e.signals.domDidMove,[a,s,r])}}}getApprovedNode(e,t){let n=e;const o=null!=t.def.domCloneMode?t.def.domCloneMode:this.settings.duplicateDOMNodeBehaviour;return('always'===o||this.externalElements.has(e))&&(n=this.settings.duplicateDOMNodeHandler?this.settings.duplicateDOMNodeHandler(e,t):o?e.cloneNode('deep'===o||'always'===o):null),n&&this.externalElements.add(n),n}createDOMNodeBy(t){var n;const o=t.def.tag;if('string'!=typeof o)return null;if('_'===o){let e=t.def.domElement&&this.getApprovedNode(t.def.domElement,t)||null;return console.log(' HA eleme',t,e),e}const s=t.def.domContent;if(s instanceof Node)return this.getApprovedNode(s,t);const r=this.settings;if(t.def.domHTMLMode)return null!=s&&''!==s?HostRender.domNodeFrom(s.toString(),o||r.renderHTMLDefTag,!0,r.renderInnerHTML,t):null;if(o)return this.inBrowser?e.createDOMElement(o,null===(n=t.parent)||void 0===n?void 0:n.domNode,r.renderSVGNamespaceURI):null;let i=null,d='',a='';if(null!=s){a=(r.renderTextHandler?r.renderTextHandler(s):s).toString();const e=r.renderTextTag;if(e)if('string'==typeof e)d=e;else if('function'==typeof e){const t=e(s);t instanceof Node&&(i=t)}}if(!i){if(!this.inBrowser)return null;i=d?document.createElement(d):document.createTextNode(a)}return d&&a&&(i.textContent=a),i}static escapeHTML(e){return e.replace(/\&(?!(\w+;))/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}static findInsertionNodes(e){let t=null,n=e.parent;for(;n;){if(!(o[n.type]||'root'===n.type&&n.parent)){t=n.domNode;break}n=n.parent}if(!t)return[null,null];let s=null,r=e;for(;r&&(n=r.parent,n);){let e,o=n.children.indexOf(r)+1;for(;e=n.children[o];){if(e.domNode&&'portal'!==e.type){s=e.domNode;break}o++}if(s||n.domNode===t)break;r=n}return[t,s]}static updateDOMChainBy(e,t,n=!1){let s=e,r=n?e:e.parent,i=t;for(;r&&(o[r.type]||r===s);){if(r.children[0]!==s&&r!==s){let e=!1,t=r.children.indexOf(s)-1;for(;t>=0;){if(r.children[t].domNode){e=!0;break}t--}if(e)break}if(!i){let e,t=r.children.indexOf(s)+1;for(;e=r.children[t];){if(e.domNode&&'portal'!==e.type){i=e.domNode;break}t++}if(i&&r.domNode===i)break}r.domNode=i,s=r,r=r.parent}}static domNodeFrom(e,t='div',n=!1,o,s){const r=t instanceof Element?t:'object'==typeof document?document.createElement(t):null;if(!r)return null;if(o&&s){const t=o(e,s,r);if('string'!=typeof t)return t||null;r.innerHTML=t}else r.innerHTML=e;return n||r.children[1]?r:r.children[0]||null}static readDOMString(t,n=!1,o=-1,s=e.domSelfClosingTags){const r=t.def;if(!r)return'';let i=r.tag;if('string'!=typeof i)return t.children?t.children.reduce(((e,t)=>'portal'===t.type?e:e+HostRender.readDOMString(t,n,o,s)),''):'';let d,a='';if(i)'_'===i&&(i=r.domElement&&r.domElement.tagName.toLowerCase()||'',d=r.domElement);else{const e=r.domContent;e&&(e&&e.nodeType?d=e:a+=e.toString())}if(!i&&!d)return a;const l=o>=0?'\n'+'\t'.repeat(o):'',c=o>=0?o+1:o,u=(null!=r.domContent?r.domContent.nodeType?'':n?HostRender.escapeHTML(r.domContent.toString()):r.domContent.toString():'')+(t.children?t.children.reduce(((e,t)=>'portal'===t.type?e:e+HostRender.readDOMString(t,n,c,s)),''):'');return a+=l+e.readDOMString(i,t.domProps,u+(l&&t.children.some((e=>'dom'!==e.type||e.def.tag))?l:'')||s&&!s.includes(i),d),a}static onRemount(t,n){let{reused:o,readFromDOM:s}=t;o||(o=t.reused=new Set),n.domNode&&o.add(n.domNode);for(const[r,i,d]of HostRender.getVirtualDomPairs(n,t,!0)){if(!0!==s&&'attributes'!==s||(r.domProps=e.readDOMProps(d)),r.domNode=d,o.add(d),r.def.domHTMLMode&&i)for(const e of HostRender.flattenVirtualItems(i))o.add(e.node);if(d.parentElement){let e=r;for(;e=e.parent;)if('dom'===e.type){d.parentElement!==e.domNode&&d.parentElement.removeChild(d);break}}}if(t.vRoot)for(const e of HostRender.flattenVirtualItems(t.vRoot)){if(o.has(e.node))continue;const n=e.node;t.unused&&t.unused.add(n),t.removeUnused&&n.parentElement&&n.parentElement.removeChild(n)}}static createVirtualItemsFor(e){var t,n;let o=null;const s={};if(o={tag:(null===(t=e.tagName)||void 0===t?void 0:t.toLowerCase())||'',node:e,parent:null},e.childNodes[0]){let t,r=[[[...e.childNodes],o]],i=0;for(;t=r[i];){i++;const[e,o]=t;o.children||(o.children=[]);let d=[];for(const t of e){const e={tag:(null===(n=t.tagName)||void 0===n?void 0:n.toLowerCase())||'',node:t,parent:o},r=t instanceof Element?t.getAttribute('_key'):null;null!=r&&(e.key=r,(s[e.tag]||(s[e.tag]=[])).push(e)),o.children.push(e),t.childNodes[0]&&d.push([[...t.childNodes],e])}d[0]&&(r=d.concat(r.slice(i)),i=0)}}return{vRoot:o,vKeyedByTags:s}}static flattenVirtualItems(e){let t,n=[e],o=0;for(;t=n[o++];)t.children&&t.children[0]&&(n=n.slice(0,o).concat(t.children.concat(n.slice(o))));return n}static getVirtualDomPairs(e,t,n){const{vRoot:o,vKeyedByTags:s,validator:r,suggester:i}=t,d=t.reused||new Set;let a,l=[],c=[[e,o||null]],u=0;for(;a=c[u++];){let[e,t]=a;if('dom'===e.type){const o=HostRender.getTreeNodeMatch(e,t,s,d,r,i);if(o){let n;o instanceof Node?(n=o,l.push([e,null,o])):(t=o,n=t.node),l.push([e,o===n?null:o,n]),d.add(n)}else n||l.push([e,t,null]),e.domNode&&d.add(e.domNode)}e.children[0]&&(c=e.children.map((e=>[e,t])).concat(c.slice(u)),u=0)}return l}static getTreeNodeMatch(e,t,n,o,s,r){const i=e.def.tag,d=e.def.key;if(r){const n=r(t,e,i,d);if(n){if((n instanceof Element?n.tagName.toLowerCase():'')===i&&(n instanceof Node?!(null==o?void 0:o.has(n)):!(null==o?void 0:o.has(n.node))&&HostRender.isVirtualItemOk(e,n,t,s)))return n}}const a=null!=d;if(t)for(const n of t.children?[t,...t.children]:[t])if(!n.used&&n.tag===i&&(a?n.key===d:null==n.key)&&!(null==o?void 0:o.has(n.node))&&(!s||s(n,e,i,d)))return n;if(n&&a){const r=n[i];if(r)for(const n of r)if(!n.used&&n.key===d&&!(null==o?void 0:o.has(n.node))&&HostRender.isVirtualItemOk(e,n,t,s))return n}return null}static isVirtualItemOk(e,t,n,o){if(t.tag!==e.def.tag)return!1;const s=e.def;if(n){let r=t;for(;r;){if(r===n)return!o||o(t,e,s.tag,s.key);r=r.parent}}else if(!o||o(t,e,s.tag,s.key))return!0;return!1}}class PseudoFragment{constructor(e){}}PseudoFragment.MIX_DOM_CLASS='Fragment';class PseudoPortal{constructor(e){}}PseudoPortal.MIX_DOM_CLASS='Portal';class PseudoElement{constructor(e){}}PseudoElement.MIX_DOM_CLASS='Element';class PseudoEmpty{constructor(e){}render(){return null}}PseudoEmpty.MIX_DOM_CLASS='Empty';class PseudoEmptyRemote extends PseudoEmpty{constructor(e,t){super(e,t)}static isRemote(){return!1}}PseudoEmptyRemote.MIX_DOM_CLASS='EmptyRemote',PseudoEmptyRemote.Content=null,PseudoEmptyRemote.ContentCopy=null,PseudoEmptyRemote.copyContent=e=>null,PseudoEmptyRemote.filterContent=(e,t)=>null,PseudoEmptyRemote.wrapContent=(e,t)=>null,PseudoEmptyRemote.renderContents=e=>null,PseudoEmptyRemote.hasContent=e=>!1,PseudoEmptyRemote.WithContent=(e,t)=>null,PseudoEmptyRemote.sources=[];class ComponentContextAPI extends t.ContextAPI{afterRefresh(e=!1,t,n){return e?(this.host.triggerRefresh(t,n),this.awaitDelay()):this.host.afterRefresh(!1,t,n)}awaitDelay(){return this.host.afterRefresh(!0)}}function mixinComponent(e){var n;return(n=class Component extends(t.mixinSignalMan(e)){constructor(e,t,...n){super(...n),this.props=e,t&&(this.boundary=t,t.component=this)}initContextAPI(){if(this.contextAPI)return;this.contextAPI=new ComponentContextAPI;const e=this.contextAPI.host=this.boundary.host;e.contextComponents.add(this),this.contextAPI.setContexts(e.contextAPI.contexts,!1,!0);const t=this.boundary._outerDef.attachedContexts;if(t)for(const e in t)this.contextAPI.setContext(e,t[e],!1)}isMounted(){return!0===this.boundary.hasMounted}getRenderedState(e=!0){return this.renderedState||e&&this.state||null}getHost(){return this.boundary.host}queryElement(e,t=!1,n=!1){return domElementByQuery(this.boundary.treeNode,e,t,n)}queryElements(e,t=0,n=!1,o=!1){return domElementsByQuery(this.boundary.treeNode,e,t,n,o)}findElements(e=0,t=!1,n=!1,o){return treeNodesWithin(this.boundary.treeNode,new Set(['dom']),e,t,n,o).map((e=>e.domNode))}findComponents(e=0,t=!1,n=!1,o){return treeNodesWithin(this.boundary.treeNode,new Set(['boundary']),e,t,n,o).map((e=>e.boundary&&e.boundary.component))}findTreeNodes(e,t=0,n=!1,o=!1,s){const r=e?Array.isArray(e)?new Set(e):'[object Set]'===e.toString()?e:new Set(Object.keys(e)):void 0;return treeNodesWithin(this.boundary.treeNode,r,t,n,o,s)}setTimer(e,t,n){return null==e&&(e={}),this.timers?this.timers.has(e)&&this.clearTimers(e):this.timers=new Map,this.timers.set(e,setTimeout((()=>{this.clearTimers(e),t.call(this)}),n)),e}hasTimer(e){return!!this.timers&&this.timers.has(e)}clearTimers(...e){if(this.timers)if(e.length)for(const t of e){const e=this.timers.get(t);null!=e&&(clearTimeout(e),this.timers.delete(t))}else this.timers.forEach((e=>clearTimeout(e))),this.timers.clear()}setUpdateModes(e,t=!0){t&&this.updateModes||(this.updateModes={});for(const t in e)this.updateModes[t]=e[t]}setConstantProps(e,t=!0,n=null){var o,s;t&&this.constantProps||(this.constantProps={});let r=!1;if(e)if(Array.isArray(e))for(const t of e)this.constantProps[t]=null===(o=(r=!0)&&n)||void 0===o||o;else for(const t in e)this.constantProps[t]=null!==(s=(r=!0)&&n)&&void 0!==s?s:e[t];r||t||delete this.constantProps}setState(e,t=!0,n,o,s){this.boundary.updateBy({state:t?Object.assign(Object.assign({},this.state),e):Object.assign({},e)},n,o,s)}setInState(e,t,n,o,s){this.boundary.updateBy({state:Object.assign(Object.assign({},this.state),{[e]:t})},n,o,s)}triggerUpdate(e,t,n){this.boundary.host.services.absorbUpdates(this.boundary,{force:e||!1},!0,t,n)}addWired(e){this.wired?this.wired.add(e):this.wired=new Set([e])}removeWired(e){var t;null===(t=this.wired)||void 0===t||t.delete(e)}afterRefresh(e=!1,t,n){return e?(this.boundary.host.triggerRefresh(t,n),this.awaitDelay()):this.boundary.host.afterRefresh(!1,t,n)}awaitDelay(){return this.boundary.host.afterRefresh(!0)}render(e,t){return null}}).MIX_DOM_CLASS='Component',n}class Component extends(mixinComponent(Object)){constructor(e,t){super(e,t)}}function createComponent(e,t,n){const o=t&&'object'==typeof t?t:void 0,s=(o?n:t)||e.name||'[createComponent]',r=e.length>1?{[s]:(t,n,o)=>e(n,o)}[s]:{[s]:(t,n)=>e(n)}[s];if(o)for(const e in o)r[e]=o[e];return r}function createComponentCtx(e,t,n){const o=t&&'object'==typeof t?t:void 0,s=(o?n:t)||e.name||'[createComponentCtx]',r={[s]:(t,n,o)=>e(n,o)}[s];if(o)for(const e in o)r[e]=o[e];return r}class BaseBoundary{constructor(e,t,n){this.host=e,this.treeNode=n,this._outerDef=t,this._innerDef=null,this.hasMounted=!1,this.sourceBoundary=null,this.parentBoundary=null,this.innerBoundaries=[]}}class ContentBoundary extends BaseBoundary{constructor(e,t,n,o){super(o.host,e,n),this.sourceBoundary=o,this.targetDef=t,this._innerDef=newAppliedDef(t,o.closure)}updateEnvelope(e,t){this.targetDef=e,t&&(this._innerDef.childDefs=t.childDefs)}}class ContentClosure{constructor(e,t){this.thruBoundary=e||null,this.sourceBoundary=t||null,this.envelope=null,this.truePassDef=null,this.groundedDefs=new Map,this.pendingDefs=new Set}hasContent(){var e;return!(!(null===(e=this.envelope)||void 0===e?void 0:e.applied)||!hasContentInDefs(this.envelope.applied.childDefs,!1))}readContent(e=!1){if(!this.envelope)return null;const t=this.envelope.applied,n=t.childDefs;if('fragment'===t.MIX_DOM_DEF&&(!n.length||n[0].disabled&&1===n.length))return null;const o=this.envelope.target.childDefs;return e?o.slice():o}}class SourceBoundary extends BaseBoundary{constructor(e,t,n,o){super(e,t,n),this.bId=e.services.createBoundaryId(),this.sourceBoundary=o||null,this.closure=new ContentClosure(this,o)}reattach(){this.component=null;const e=this._outerDef.props||{};let n=this._outerDef.tag;if('function'==typeof n){const o=n.api,s=n.MIX_DOM_CLASS?null:this._outerDef.tag,r=s&&s.length>=3||!1,i=this.component=new(s?SourceBoundary.getComponentFuncClass(s):n)(e,this);if(this.component=i,r&&i.initContextAPI(),s&&(i.render=r?e=>s.call(i,e,i,i.contextAPI):e=>s.call(i,e,i)),i.boundary||(i.boundary=this),o){i.constructor.api=o,o.components.add(i);for(const e in o.signals)for(const t of o.signals[e]){const[n,o,s]=t;i.listenTo(e,((...e)=>o?n(i,...e,...o):n(i,...e)),null,s,n)}}'Remote'===n.MIX_DOM_CLASS&&(this.closure.remote=i,n.addSource(i)),i.signals.preMount&&t.callListeners(i.signals.preMount)}else this.component=new Component(e,this)}update(e,t,n){this.host.services.absorbUpdates(this,{force:!1===this.hasMounted?'all':e||!1},!0,t,n)}updateBy(e,t,n,o){this.host.services.absorbUpdates(this,Object.assign(Object.assign({},e),{force:!1===this.hasMounted?'all':t||!1}),!0,n,o)}render(e=0){const t=!1===this.hasMounted&&!this._renderPhase;e||(this._renderPhase='active');const n=this.component,o=n.render(n.props||{},n.state),s='function'==typeof o;if(s&&(n.render=o),t&&n.contextAPI&&n.contextAPI.callDataBy(),s)return this.render(e);if('re-updated'===this._renderPhase){const t=this.host.settings;if(t.maxReRenders<0||e<t.maxReRenders)return e++,this._renderPhase='active',this.render(e);t.debugMode&&console.warn('__SourceBoundary.render: Warning: The component tried to render for over '+(e+1).toString()+' times.',this._outerDef.tag.MIX_DOM_CLASS?n.constructor:this._outerDef.tag,n)}return delete this._renderPhase,o}static getComponentFuncClass(e){let t=!1;for(const n in e){t=!0;break}if(!t)return Component;const n={[e.name]:class extends Component{}}[e.name];for(const t in e)n[t]=e[t];return n}}class ComponentShadowAPI extends t.SignalBoy{constructor(){super(...arguments),this.components=new Set}update(e=!0,t,n){for(const o of this.components)o.triggerUpdate(e,t,n)}static onListener(e,t,n,o){if(e.components.size&&e.signals[t]){const s=e.signals[t][n],r=s[0];if(o)for(const n of e.components)n.listenTo(t,((...e)=>s[1]?r(n,...e,...s[1]):r(n,...e)),null,s[2],r);else for(const n of e.components)n.unlistenTo(t,r)}}}function prepareShadow(e,t,n){if(n)for(const t in n)e[t]=n[t];if(e.api=new ComponentShadowAPI,t)for(const n in t)e.api.listenTo(n,t[n])}class ComponentWiredAPI extends ComponentShadowAPI{constructor(){super(),this.updateModes={props:'never'},this.builtProps=null}buildProps(){return this.onBuildProps?this.onBuildProps(this.builtProps):this.builtProps}getMixedProps(e){return this.onMixProps?this.onMixProps(e.props,this.builtProps,e):Object.assign(Object.assign({},e.props),e.state)}setProps(e,t,n,o){(this.builtProps!==e||t||void 0!==n||void 0!==o)&&(this.builtProps=e,this.update('trigger'!==t&&t,n,o))}refresh(e,t,n){this.setProps(this.buildProps(),e,t,n)}update(e=!0,t,n){for(const o of this.components)o.setState(this.getMixedProps(o),!1,e,t,n)}}const d={fragment:1,portal:2,pass:3,host:4};function assignTreeNodesFor(e,t,n,s,r){t.children[0]&&(t.children=[]);const i=e.length;if(!i)return[];const d=[];let a=0,l=null,c=t;if(n){if(!t.parent)return[];if(c=t.parent,l=t,a=c.children.indexOf(t),-1===a)return[]}for(let t=0;t<i;t++){const n=e[t];if(n.disabled){a--,d.push(null);continue}let i=null;n.treeNode?i=n.treeNode:'fragment'!==n.MIX_DOM_DEF&&(n.action='mounted'),l&&(i?c.children.splice(a,1):i=l,l=null);const u=n.MIX_DOM_DEF,p='content'===u||'element'===u?'dom':'fragment'===u?'':u;if(i){if(i.parent){const e=i.parent.children.indexOf(i);0===e&&i.parent!==c&&!0===o[i.parent.type]&&r&&-1===r.indexOf(i.parent)&&r.push(i.parent),-1!==e&&i.parent.children.splice(e,1)}i.parent=c,i.sourceBoundary=s||null,i.type=p}else i={type:p,parent:c,children:[],sourceBoundary:s||null,domNode:null},'dom'===i.type&&(i.domProps={});'fragment'!==n.MIX_DOM_DEF&&(i.def=n,n.treeNode=i),c.children.splice(a+t,0,i),d.push(i)}return d}function findAppliedDefsFor(e,t,o,s,r,i,a){var l,c,u,p,f,h;let m=t.childDefs.length;if(!m)return[];const g=i||!t.isArray;if(!i&&t.isArray!=(e&&e.isArray))return t.childDefs.map((e=>newAppliedDef(e,r&&r.closure||null)));const y=e&&e.childDefs||null,D=[];for(let i=0;i<m;i++){const m=t.childDefs[i],C=null!=m.key,M=m.MIX_DOM_DEF,b=m.getRemote||d[M]||m.tag;let v=!1,N=null;if(y)for(const e of y)if((C?e.key===m.key:null==e.key)&&b===(e.getRemote||d[e.MIX_DOM_DEF]||e.tag)&&s.has(e)&&M===e.MIX_DOM_DEF&&('content'===M?!m.domHTMLMode==!e.domHTMLMode:'boundary'!==M||!(null===(u=null===(c=null===(l=e.treeNode)||void 0===l?void 0:l.boundary)||void 0===c?void 0:c.component)||void 0===u?void 0:u.constantProps)||n.areEqualBy(m.props,e.props,e.treeNode.boundary.component.constantProps))){N=e,s.delete(e),N.updateId&&N.updateId!==a&&delete N.updateId;break}if(!N&&C&&g){const e=o&&o.get(b);if(e)for(const t of e)if(t.key===m.key&&s.has(t)&&M===t.MIX_DOM_DEF&&('content'===M?!m.domHTMLMode==!t.domHTMLMode:'boundary'!==M||!(null===(h=null===(f=null===(p=t.treeNode)||void 0===p?void 0:p.boundary)||void 0===f?void 0:f.component)||void 0===h?void 0:h.constantProps)||n.areEqualBy(m.props,t.props,t.treeNode.boundary.component.constantProps))){N=t,s.delete(t),v=!0;for(const e of allDefsIn(N))e.updateId=a;break}}N?N.action=v||!e||e.childDefs[i]!==N?'moved':'updated':N=newAppliedDef(m,r&&r.closure||null),D.push(N)}return D}function buildDefMaps(e,t=!1,n=new Set,o){const s=new Map;let r,i=t?e.childDefs.slice():[e],a=0;for(;r=i[a];){a++,n.add(r);const e=r.getRemote||d[r.MIX_DOM_DEF]||r.tag,t=s.get(e);if(t?t.push(r):s.set(e,[r]),r.scopeType)if('spread-pass'===r.scopeType)o&&o.push(r);else{const e=[];r.scopeMap=buildDefMaps(r,!0,n,e)[0],e[0]&&(i=e[0].childDefs.concat(i.slice(a)),a=0)}else r.childDefs[0]&&(i=r.childDefs.concat(i.slice(a)),a=0)}return[s,n]}function runPassUpdate(e,t=!1){const[n,o,s]=function assignTreeNodesForPass(e){const t=e._innerDef,n=e.sourceBoundary,o=[],s=[],r=[];let i,d=[[e.targetDef,t,e.treeNode,!1]],a=0;for(;i=d[a];){a++;const[e,t,l,c]=i;if(c&&!e.childDefs[0]&&l&&!l.type&&l.parent){const e=l.parent.children,t=e.indexOf(l);-1!==t&&e.splice(t,1),l.sourceBoundary=null}else{if(t.childDefs[0]){const r=l&&'boundary'!==e.MIX_DOM_DEF&&('element'!==e.MIX_DOM_DEF||e.domElement)?assignTreeNodesFor(t.childDefs,l,c,n,s):[];let i=0;const u=[];for(const n of t.childDefs){const t=r[i]||null;!t&&n.treeNode&&(o.push(n.treeNode),n.treeNode.sourceBoundary=null),u.push([e.childDefs[i],n,t,'fragment'===n.MIX_DOM_DEF]),i++}d=u.concat(d.slice(a)),a=0}l&&!t.disabled&&r.push([e,t,l])}}return[r,o,s]}(e);let[r,i]=applyDefPairs(e,n,t);if(o[0]){const e=new Set;for(const t of o)t.sourceBoundary||(t.def&&e.add(t.def),t.parent=null);if(e.size){const t=cleanUpDefs(e);r=t[0].concat(r),i=t[1].concat(i)}}return s[0]&&(r=s.map((e=>({treeNode:e,emptyMove:!0}))).concat(r)),e.hasMounted||(e.hasMounted='pre'),[r,i]}function runBoundaryUpdate(e,t=!1){let n,o,s=null,r=e._innerDef;e.bId?(s=newDefFrom(e.render()),s&&!r&&(r=newAppliedDef(s,e.closure))):s=e.targetDef;const[i,d]=r?buildDefMaps(r):[new Map,new Set],a=[];if(s){const l=[],c=function pairDefs(e,t,n,o,s,r,i){const d=e.host.settings,a=d.noRenderValuesMode,l=d.wideKeysInArrays,c=[],u=e.bId?e:e.sourceBoundary;let p,f=[[{childDefs:[t]},{childDefs:[n]},e.treeNode,!1,null]],h=0;for(;p=f[h];){h++;const[t,n,d,m]=p,g='spread-pass'===n.scopeType?void 0:n.scopeMap||p[5];if(t.childDefs[0]){const c=findAppliedDefsFor(n,t,g||o,s,u,l,e.host.services._whileUpdating);n.childDefs=c;for(let e,o=0;e=t.childDefs[o];o++)if('content'===e.MIX_DOM_DEF){const t=n.childDefs[o];a&&(!0===a?!e.domContent:a.includes(e.domContent))?t.disabled=!0:delete t.disabled}const y='boundary'===t.MIX_DOM_DEF,D=p[4]||y&&n;y&&delete n.hasPassWithin;const C=!d||y||'element'===t.MIX_DOM_DEF&&!t.domElement?[]:assignTreeNodesFor(c,d,m,u,i),M=[];for(let e,n=0;e=t.childDefs[n];n++){const t=C[n]||null,o=c[n];!t&&o.treeNode&&(o.treeNode.sourceBoundary=null,r&&r.push(o)),D&&'pass'===e.MIX_DOM_DEF&&(D.hasPassWithin=!0);const s=[e,o,t,'fragment'===e.MIX_DOM_DEF,D||'boundary'===e.MIX_DOM_DEF&&o||null];M.push(s),g&&(s[5]=g)}f=M.concat(f.slice(h)),h=0}else n.childDefs=[];d&&t.MIX_DOM_DEF&&n.MIX_DOM_DEF&&c.push([t,n,d])}return c}(e,s,r,i,d,l,a);if(e._innerDef=c[0][1],[n,o]=applyDefPairs(e,c,t),l[0])for(const e of l){const t=e.treeNode;t&&null===t.sourceBoundary&&d.add(e)}}else n=[],o=[],!r&&e.hasMounted||a.push(e.treeNode),e.innerBoundaries=[],e.treeNode.children=[],e._innerDef=null;if(d.size){const e=cleanUpDefs(d);n=e[0].concat(n),o=e[1].concat(o)}return a[0]&&(n=a.map((e=>({treeNode:e,emptyMove:!0}))).concat(n)),e.hasMounted||(e.hasMounted='pre'),[n,o]}function applyDefPairs(t,n,o=!1){var s,i;const d=t.bId?t:t.sourceBoundary,a=[],l=t.host.settings.preCompareDOMProps;t.innerBoundaries=[];let c=[[],[]];for(const u of n){const[n,p,f]=u,h='mounted'===p.action;if(!h&&'moved'===p.action)switch(p.MIX_DOM_DEF){case'fragment':for(const e of rootDOMTreeNodes(f,!0,!0))-1===a.indexOf(e)&&(a.push(e),c[0].push({treeNode:e,move:!0}));break;case'host':p.host&&p.host.groundedTree.parent===f&&c[0].push({treeNode:f,move:!0})}if('fragment'===p.MIX_DOM_DEF)continue;if('pass'===f.type){if('pass'!==p.MIX_DOM_DEF)continue;let e=r.key;if(p.getRemote){const n=p.getRemote();e=null===(s=n.Content)||void 0===s?void 0:s.key,mergeChangesTo(c,groundClosureContent(n.closure,p,t,f,p.key!==e?p.key:null))}else p.contentPass&&mergeChangesTo(c,groundClosureContent(p.contentPass,p,t,f,p.key!==e?p.key:null));f.boundary&&t.innerBoundaries.push(f.boundary);continue}const m=p.props;let g=!1;n.props&&(f.boundary&&(f.boundary._outerDef.props=n.props),p.props=n.props||{});let y=!1;switch(p.MIX_DOM_DEF){case'content':y=!0,g=p.domContent!==n.domContent,g&&(p.domContent=n.domContent),n.domHTMLMode&&(p.domHTMLMode=!0);break;case'dom':y=!0;break;case'element':y=!0,p.domElement!==n.domElement&&(h||c[0].push({treeNode:f,swap:!0}),p.domElement=n.domElement||null),p.domCloneMode=null!=n.domCloneMode?n.domCloneMode:null;break;case'portal':p.domPortal!==n.domPortal&&(c[0].push({treeNode:f,[h?'create':'swap']:!0}),p.domPortal=n.domPortal||null);break;case'boundary':if(h){n.attachedContexts&&(p.attachedContexts=n.attachedContexts);const e=new SourceBoundary(t.host,p,f,d);e.parentBoundary=t,f.boundary=e}break;case'host':if(p.host){const e=p.host;let t=e;if('mounted'===p.action){if(e.groundedTree.parent){const n=t.settings.duplicatableHost;if('function'==typeof n){const e=n(p.host,f);if(!e)break;if('object'==typeof e){if(e.groundedTree.parent)break;t=e}}else if(!n)break;const o=e.shadowAPI;t===e?t=new e.constructor(e.services.getRootDef(!0),null,e.settings,null,o):t.shadowAPI!==e.shadowAPI&&(t.shadowAPI.hosts.delete(t),t.shadowAPI=e.shadowAPI);for(const e in o.contexts){const n=o.contexts[e];n&&t.contextAPI.setContext(e,n,!1)}p.host=t}e.shadowAPI.hosts.add(t)}t.groundedTree.parent=f,f.children=[t.groundedTree],c[0].push({treeNode:f,move:!0});break}}if(y){if(h)c[0].push({treeNode:f,create:!0});else{const t='moved'===p.action&&-1===a.indexOf(f),o=!!p.tag&&(!l||'if-needed'===l&&(g||t)||!e.equalDOMProps(m||{},n.props||{}));if(o||g||t){const e={treeNode:f};o&&(e.update=!0),g&&(e.content=!0),t&&(e.move=!0,a.push(f)),c[0].push(e)}}p.attachedSignals!==n.attachedSignals&&(n.attachedSignals?p.attachedSignals=n.attachedSignals:delete p.attachedSignals)}if(f.boundary){const s=f.boundary;if(t.innerBoundaries.push(s),h){if(p.tag&&p.tag._WithContent){const e=p.tag._WithContent,t=e.getRemote?e.getRemote().closure:d.closure;(t.withContents||(t.withContents=new Set)).add(s)}s.reattach()}const r=s.component;if(p.attachedSignals!==n.attachedSignals){const t=e.getDictionaryDiffs(p.attachedSignals||{},n.attachedSignals||{});if(t)for(const e in t)t[e]?r.listenTo(e,t[e]):r.unlistenTo(e,p.attachedSignals[e]);p.attachedSignals=n.attachedSignals}if(p.attachedContexts!==n.attachedContexts){if(r.contextAPI){const t=e.getDictionaryDiffs(p.attachedSignals||{},n.attachedSignals||{});if(t){for(const e in t)t[e]?r.contextAPI.setContext(e,t[e]):r.contextAPI.setContext(e,null);r.contextAPI.callDataBy(h||Object.keys(t))}}p.attachedContexts=n.attachedContexts}let l=null;const u=s.closure.envelope;n.childDefs[0]&&(l=u?{applied:Object.assign(Object.assign({},u.applied),{childDefs:p.childDefs,action:p.action}),target:Object.assign(Object.assign({},u.target),{childDefs:n.childDefs})}:{applied:{tag:null,MIX_DOM_DEF:'fragment',childDefs:p.childDefs,action:'mounted'},target:{tag:null,MIX_DOM_DEF:'fragment',childDefs:n.childDefs}});const m=u||l?s.closure:null;let g=null;if(m){g=preRefreshClosure(m,l);const e=d.closure;p.hasPassWithin?(e.chainedClosures||(e.chainedClosures=new Set)).add(m):null===(i=e.chainedClosures)||void 0===i||i.delete(m)}mergeChangesTo(c,t.host.services.updateBoundary(s,o,a,g)),m&&mergeChangesTo(c,applyClosureRefresh(m,o))}if(p.attachedRefs||n.attachedRefs){const e=p.attachedRefs,t=n.attachedRefs;if(e)for(const n of e)t&&t.includes(n)||Ref.willDetachFrom(n,f);if(t)for(const n of t)e&&e.includes(n)||Ref.didAttachOn(n,f);p.attachedRefs=t}}return c}function cleanUpDefs(e,t=!0,n=!0){var o;let s=[[],[]];for(const r of e){const e=r.treeNode;if(e){switch(r.MIX_DOM_DEF){case'dom':case'element':case'content':n&&s[0].push({treeNode:e,remove:!0});break;case'boundary':e.boundary&&mergeChangesTo(s,destroyBoundary(e.boundary,!1,n));break;case'pass':(r.contentPass||r.getRemote)&&mergeChangesTo(s,ungroundClosureContent(r.contentPass||r.getRemote().closure,r));case'host':{const t=r.host;if(t&&t.groundedTree.parent===e){t.groundedTree.parent=null,e.children=[],s[0].push({treeNode:e,move:!0}),t.shadowAPI.hosts.delete(t);const n=t.contextAPI.getContexts(null,!0,!0);for(const e in n)n[e].contextAPIs.delete(t.contextAPI)}}default:if(r.attachedRefs&&r.MIX_DOM_DEF)for(const t of r.attachedRefs)Ref.willDetachFrom(t,e)}t&&('pass'===(null===(o=e.parent)||void 0===o?void 0:o.type)&&e.parent.def.getRemote&&s[0].push({emptyMove:!0,treeNode:e.parent}),e.parent=null,e.sourceBoundary=null,delete r.treeNode)}}return s}function destroyBoundary(e,n=!0,o=!0){var s,r,i;let d=[[],[]];if(null===e.hasMounted)return d;const a=e.bId?e:null;if(a){const e=a.component,n=e.constructor;e.signals.willUnmount&&t.callListeners(e.signals.willUnmount);const o=a._outerDef;if(o.attachedRefs)for(const e of o.attachedRefs)Ref.willDetachFrom(e,a.treeNode);if(null===(r=null===(s=a.sourceBoundary)||void 0===s?void 0:s.closure.chainedClosures)||void 0===r||r.delete(a.closure),e.contextAPI){const t=e.contextAPI,n=t.getContexts(null,!0,!0);for(const e in n)n[e].contextAPIs.delete(t);t.contexts={},a.host.contextComponents.delete(e)}if(n.api&&(n.api.components.delete(e),n.api.signals&&(n.api.signals={})),'Remote'===n.MIX_DOM_CLASS&&mergeChangesTo(d,n.removeSource(e)),o.tag._WithContent){const e=o.tag._WithContent,t=e.getRemote?e.getRemote().closure:null===(i=a.sourceBoundary)||void 0===i?void 0:i.closure;(null==t?void 0:t.withContents)&&(t.withContents.delete(a),t.withContents.size||delete t.withContents)}e.signals&&(e.signals={}),e.timers&&e.clearTimers()}return o&&(d[0]=d[0].concat(rootDOMTreeNodes(e.treeNode,!0).map((e=>({treeNode:e,remove:!0}))))),e._innerDef&&mergeChangesTo(d,cleanUpDefs(allDefsIn(e._innerDef,!0),n,!1)),a&&a.host.services.cancelUpdates(a),e.hasMounted=null,d}function groundClosureContent(e,t,n,o,s){return e.groundedDefs.get(t)?'moved'===t.action&&o.boundary?[rootDOMTreeNodes(o.boundary.treeNode,!0,!0).map((e=>({treeNode:e,move:!0}))),[]]:[[],[]]:(e.groundedDefs.set(t,[n,o,s]),applyContentDefs(e,[t]))}function ungroundClosureContent(e,t){const n=e.groundedDefs.get(t);if(!n)return[[],[]];e.groundedDefs.delete(t),e.pendingDefs.delete(t),e.truePassDef===t&&(e.truePassDef=null);const o=n[1].boundary;return o?destroyBoundary(o):[[],[]]}function preRefreshClosure(e,t,n){if(e.remote)return e.envelope=t,preRefreshClosure(e.remote.closure,t,e.remote);if(!e.envelope&&!t)return null;const o=collectInterestedInClosure(e,n);if(o)for(const e of o)e._forceUpdate=e._forceUpdate||!0;return e.envelope=t,e.pendingDefs=new Set(e.groundedDefs.keys()),o}function applyClosureRefresh(e,t=!1){if(e.remote)return applyClosureRefresh(e.remote.closure,t);let n=[],o=[];return e.pendingDefs.size&&([n,o]=applyContentDefs(e,e.pendingDefs,t)),[n,o]}function applyContentDefs(e,t,n=!1){let o=[],s=[];for(const r of t){e.pendingDefs.delete(r);const t=e.groundedDefs.get(r);if(void 0===t)continue;let[i,d,a]=t,l=d.boundary;if(e.envelope&&e.sourceBoundary){let t=!0;const c=e.envelope;l?(t=e.truePassDef===r,l.updateEnvelope(c.target,t?c.applied:null)):(l=new ContentBoundary(r,c.target,d,e.sourceBoundary),t=null==a&&(!e.truePassDef||e.truePassDef===r),t&&(l._innerDef.childDefs=c.applied.childDefs,e.truePassDef=r),l.parentBoundary=i,d.boundary=l);const[u,p]=t?runPassUpdate(l,n):runBoundaryUpdate(l,n);o=o.concat(u),s=s.concat(p)}else if(l){const e=destroyBoundary(l,!1);o=o.concat(e[0]),s=s.concat(e[1]),d.boundary=null}}return[o,s]}var a;const checkRecursively=e=>{var t;return!(!(null===(t=e.contentPass)||void 0===t?void 0:t.envelope)||!hasContentInDefs(e.contentPass.envelope.applied.childDefs,checkRecursively))},l=((a=class WithContent extends Component{hasContent(){var e;const t=null===(e=this.boundary.sourceBoundary)||void 0===e?void 0:e.closure;return t&&t.envelope&&hasContentInDefs(t.envelope.applied.childDefs,checkRecursively)||!1}render(){var e;return(null!==(e=this.props.hasContent)&&void 0!==e?e:this.hasContent())?r:null}})._WithContent=r,a);function mergeShadowWiredAPIs(e){const t=e.some((e=>e instanceof ComponentWiredAPI))?new ComponentWiredAPI:new ComponentShadowAPI;for(const n of e){if(n.updateModes){t.updateModes||(t.updateModes={});for(const e in n.updateModes)t.updateModes[e]=Object.assign(Object.assign({},t.updateModes[e]),n.updateModes[e])}for(const e in n.signals)t.signals[e]=[...t.signals[e]||[],...n.signals[e]];n instanceof ComponentWiredAPI&&(n.builtProps&&(t.builtProps=n.builtProps),n.onBuildProps&&(t.onBuildProps=n.onBuildProps),n.onMixProps&&(t.onMixProps=n.onMixProps))}return t}function mixFuncs(...e){const t=e.filter((e=>'function'==typeof e)),n=t.some((e=>e.length>2));let o=e.slice(t.length);'string'==typeof o[1]&&(o=[o[1],o[0]]);const s=!0===o[0]||!0===o[1],r='string'==typeof o[0]&&o[0]||'[mixedFunc'+(n?'Ctx':'')+']',CompFunc=(e,n,o)=>{let r=null;for(const s of t){if(!s)continue;const t=n.state,i=s(e,n,o);'function'!=typeof i&&'function'==typeof r||(r=i),t!==n.state&&n.state&&(n.state=Object.assign(Object.assign({},t||{}),n.state))}return s?()=>r:r},i=n?{[r]:(e,t,n)=>CompFunc(e,t,n)}[r]:{[r]:(e,t)=>CompFunc(e,t)}[r],d=[];for(const e of t)for(const t in e)'api'===t?d.push(e.api):i[t]=e[t];return d[0]&&(i.api=mergeShadowWiredAPIs(d)),i}function mixMixins(...e){const t=e.length,n=t&&e[0].MIX_DOM_CLASS?e[0]:null;let o,s=n||(o='string'==typeof e[t-1]&&e[t-1]||'[mixMixins]')&&{[o]:Component}[o];for(const t of n?e.slice(1):e)s=t(s);return s}function mixMixinsWith(...e){return mixMixins(...e.filter((e=>'function'==typeof e||'string'==typeof e)))}function mixClassFuncs(e,...t){const n=t.filter((e=>'function'==typeof e)),o=n.length>1?mixFuncs(...n):n[0];let s=t.slice(n.length);'string'==typeof s[1]&&(s=[s[1],s[0]]);const r=!0===s[0]||!0===s[1],i='string'==typeof s[0]&&s[0]||'['+e.name+'_mix]',d={[i]:class extends e{render(e){const t=o(e,this,this.contextAPI);return r?super.render:'function'==typeof t?t:()=>t}}}[i];for(const e in o)'api'===e?d.api=d.api?mergeShadowWiredAPIs([d.api,o.api]):o.api:d[e]=o[e];return d}class HostServices{constructor(e){this.host=e,this.bIdCount=0,this.renderer=new HostRender(e.settings,e.groundedTree),this.updateCycle=new t.RefreshCycle({initPending:()=>({updates:new Set})}),this.renderCycle=new t.RefreshCycle({initPending:()=>({rCalls:[],rInfos:[]}),autoRenewPromise:!0}),this.constructor.initializeCyclesFor(this)}createBoundaryId(){return'h-'+this.host.constructor.idCount.toString()+':b-'+(this.bIdCount++).toString()}clearTimers(e=!1){e||(this.updateCycle.resolve(),this.renderCycle.resolve()),this.updateCycle.reject(),this.renderCycle.reject()}createRoot(e){return this.rootDef=newDefFrom(e),{HostRoot:(e,t)=>()=>this._rootDisabled?null:this.rootDef}.HostRoot}updateRoot(e,t,n){this.rootDef=newDefFrom(e),this.host.rootBoundary.update(!0,t,n)}refreshRoot(e=!1,t,n){const o=!this._rootDisabled,s=this.host,r=!(s.settings.onlyRunInContainer&&!s.groundedTree.domNode&&!s.groundedTree.parent);if(r?delete this._rootDisabled:this._rootDisabled=!0,!e&&r&&o){if(r&&o){const e=s.rootBoundary?rootDOMTreeNodes(s.rootBoundary.treeNode,!0).map((e=>({treeNode:e,move:!0}))):[];this.absorbChanges(e,null,n)}}else s.rootBoundary.update(!0,t,n)}clearRoot(e=!1){this.clearTimers(e),this.rootDef=null}getRootDef(e){return this.rootDef&&(e?Object.assign({},this.rootDef):this.rootDef)}hasPending(e=!0,t=!0){return!!(e&&this.updateCycle.state||t&&this.renderCycle.state)}addRefreshCall(e,t=!1){t?this.renderCycle.promise.then(e):this.updateCycle.promise.then(e)}cancelUpdates(e){var t;null===(t=this.updateCycle.pending.updates)||void 0===t||t.delete(e)}absorbUpdates(e,t,n=!0,o,s){if(null!==e.hasMounted){if(t.force&&(e._forceUpdate='all'===e._forceUpdate?'all':t.force),t.props&&(e._outerDef.props=t.props),t.state){const n=e.component;n.renderedState||(n.renderedState=Object.assign({},n.state)),n.state=t.state}e._renderPhase?e._renderPhase='re-updated':(this.updateCycle.pending.updates.add(e),n&&this.triggerRefresh(o,s))}}triggerRefresh(e,t){this.updateRefreshTimes(e,t),this.updateCycle.trigger(this.host.settings.updateTimeout)}updateRefreshTimes(e,t){void 0!==e&&this.updateCycle.extend(e),void 0!==t&&this.renderCycle.extend(t)}updateBoundary(e,n=!1,o,s){let r=!!n,i='all'===n,d=[],a=[];const l=e.component,c=!e.hasMounted;if(c){if(null===e.hasMounted)return null;a.push([e,'mounted']),r=!0}const u=e._outerDef.props!==l.props?l.props||{}:void 0;u&&(l.props=e._outerDef.props);const p=l.constructor.api;if(p&&(c||u)&&(c&&p.onBuildProps&&!p.builtProps&&(p.builtProps=p.onBuildProps(null)),p.getMixedProps&&(c||l.renderedState||(l.renderedState=Object.assign({},l.state)),l.state=p.getMixedProps(l))),!c&&l.signals.beforeUpdate&&t.callListeners(l.signals.beforeUpdate),e._forceUpdate&&('all'===e._forceUpdate&&(i=!0),r=!0,delete e._forceUpdate),!c){const n=l.renderedState;if(n&&delete l.renderedState,r||u||n){if(!r){const o=l.signals.shouldUpdate?t.askListeners(l.signals.shouldUpdate,[u,n],['first-true','no-false']):null;(!0===o||null==o&&HostServices.shouldUpdateBy(e,u,n))&&(r=!0)}const s='moved'===e._outerDef.action;if(s&&a.push([e,'moved']),r&&a.push([e,'updated',u,n]),s)for(const t of rootDOMTreeNodes(e.treeNode,!0,!0)){if(o){if(-1!==o.indexOf(t))continue;o.push(t)}d.push({treeNode:t,move:!0})}l.signals.preUpdate&&t.callListeners(l.signals.preUpdate,[u,n,r])}}if(r){const[t,n]=runBoundaryUpdate(e,i);d=d.concat(t),a=a.concat(n)}if(l.renderedState&&delete l.renderedState,l.wired)for(const e of l.wired)if(e.api.onBuildProps&&(e.api.builtProps=e.api.onBuildProps(e.api.builtProps)),e.api.components.size){s||(s=new Set);for(const t of e.api.components)t.boundary._outerDef.props=Object.assign({},t.boundary._outerDef.props),s.add(t.boundary)}if(s&&s.size){for(const t of s)t.sourceBoundary===e.sourceBoundary&&t._updateId!==e.host.services._whileUpdating&&(t._forceUpdate=!0,s.delete(t));const t=updatedInterestedInClosure(s,!0);d=d.concat(t[0]),a=a.concat(t[1])}return d[0]||a[0]?[d,a]:null}absorbChanges(e,t,n){var o;e&&this.renderCycle.pending.rInfos.push(e),t&&this.renderCycle.pending.rCalls.push(t),this.renderCycle.trigger(null!==(o=this.host.settings.renderTimeout)&&void 0!==o?o:void 0,null!=n?n:void 0)}static initializeCyclesFor(e){e.updateCycle.listenTo('onRefresh',((t,n)=>e.constructor.runUpdates(e,t,n))),e.renderCycle.listenTo('onRefresh',((t,n)=>e.constructor.runRenders(e,t,n))),e.updateCycle.listenTo('onFinish',(()=>{e.renderCycle.trigger(e.host.settings.renderTimeout)}))}static runUpdates(e,t,n){if(!t.updates.size)return;if(e._chainedUpdates)return void e._chainedUpdates.push(t);let o;e._chainedUpdates=[t];let s=0;for(;o=e._chainedUpdates[s++];){e._whileUpdating={};let t=[],n=[];for(const s of o.updates.size>1?sortBoundaries(o.updates):o.updates){s._updateId=e._whileUpdating;const o=e.updateBoundary(s);o&&(t=t.concat(o[0]),n=n.concat(o[1]))}t[0]&&e.renderCycle.pending.rInfos.push(t),n[0]&&e.renderCycle.pending.rCalls.push(n),o=e.updateCycle.resetPending(),o.updates.size&&e._chainedUpdates.push(o)}delete e._whileUpdating,delete e._chainedUpdates}static runRenders(e,n,o){if(n.rInfos)for(const t of n.rInfos)t[0]&&e.renderer.applyToDOM(t);if(n.rCalls){for(const e of n.rCalls)for(const t of e)'mounted'===t[1]&&(t[0].hasMounted=!0);for(const e of n.rCalls)for(const n of e){const e=n[0].component,o='mounted'===n[1]?'didMount':'moved'===n[1]?'didMove':'didUpdate';e.signals[o]&&t.callListeners(e.signals[o],'updated'===n[1]?[n[2],n[3]]:void 0)}}}static shouldUpdateBy(e,t,o){var s,r,i;const d=e.component,a=e.host.settings.updateComponentModes,l=null===(s=d.constructor.api)||void 0===s?void 0:s.updateModes,c=t&&o?['props','state']:t?['props']:o?['state']:[];for(const e of c){const s=null!==(i=null!==(r=d.updateModes&&d.updateModes[e])&&void 0!==r?r:l&&l[e])&&void 0!==i?i:a[e],c='number'==typeof s?s:n.CompareDepthEnum[s]||0;if(c<-1){if(-2===c)return!0}else{if(0===c)return!0;if(!n.areEqual('state'===e?o:t,d[e],c))return!0}}return!1}}class HostShadowAPI{constructor(){this.hosts=new Set,this.contexts={}}}class HostContextAPI extends t.ContextAPI{setContext(e,t,n=!0,o=!1){return o&&(t?this.host.shadowAPI.contexts[e]=t:delete this.host.shadowAPI.contexts[e]),void 0!==this.constructor.modifyContexts(this,{[e]:t},n,!1)[0]}setContexts(e,t=!0,n=!1){if(n){const t=this.host.shadowAPI.contexts;for(const n in e)e[n]?t[n]=e[n]:delete t[n]}return this.constructor.modifyContexts(this,e,t,!1)}awaitDelay(){return this.host.services.renderCycle.promise}afterRefresh(e,t,n){return this.host.services.triggerRefresh(t,n),e?this.awaitDelay():this.host.services.updateCycle.promise}static modifyContexts(e,t,n,o){const s=super.modifyContexts(e,t,n,o);for(const o of e.host.contextComponents)o.contextAPI.setContexts(t,n,!0);return s}}class Host{constructor(e,t,n,o,s){this.constructor.idCount++,this.shadowAPI=s||new HostShadowAPI,this.contextComponents=new Set,this.contextAPI=new HostContextAPI,this.contextAPI.host=this,o&&this.contextAPI.setContexts(o,!1,!0),this.groundedTree={type:'root',parent:null,children:[],domNode:t||null,sourceBoundary:null},this.settings=Host.getDefaultSettings(),n&&Host.modifySettings(this.settings,n),this.services=new HostServices(this);const r=newAppliedDef({MIX_DOM_DEF:'boundary',tag:this.services.createRoot(e),props:{},childDefs:[]},null),i={type:'boundary',def:r,sourceBoundary:null,boundary:null,parent:this.groundedTree,children:[],domNode:null};this.groundedTree.children.push(i),this.rootBoundary=new SourceBoundary(this,r,i),i.boundary=this.rootBoundary,this.rootBoundary.reattach(),this.services.absorbUpdates(this.rootBoundary,{})}clearRoot(e=!0,t,n){this.services.clearRoot(!0),e&&this.rootBoundary.update(!0,t,n)}moveRoot(e,t){if(this.groundedTree.domNode===e)return;this.groundedTree.domNode=e;const n=rootDOMTreeNodes(this.rootBoundary.treeNode,!0).map((e=>({treeNode:e,move:!0})));(n[0]||void 0!==t)&&this.services.absorbChanges(n,null,t)}updateRoot(e,t,n){this.services.updateRoot(e,t,n)}refreshRoot(e=!1,t,n){this.services.refreshRoot(e,t,n)}refreshDOM(e=!1,t){const n=!e||'read',o=[];let s,r=[...this.groundedTree.children],i=0;for(;s=r[i];)i+=1,s.domProps&&o.push({treeNode:s,refresh:n}),s.children[0]&&(r=s.children.concat(r.slice(i)),i=0);this.services.absorbChanges(o,null,t)}afterRefresh(e=!1,t,n){return new Promise((o=>this.afterRefreshCall(o,e,t,n)))}updateRefreshTimes(e,t){this.services.updateRefreshTimes(e,t)}afterRefreshCall(e,t=!1,n,o){this.services.hasPending(!0,t)?(this.addRefreshCall(e,t),this.services.triggerRefresh(n,o)):e()}addRefreshCall(e,t=!1){this.services.addRefreshCall(e,t)}triggerRefresh(e,t){this.services.triggerRefresh(e,t)}pause(){this.services.renderer.pause()}resume(){this.services.renderer.resume()}isPaused(){return this.services.renderer.paused}reassimilate(e=null,t=!1,n=!1,o=!1,s,r){this.services.renderer.reassimilate(e||this.groundedTree.domNode,t,n,o,s,r)}reassimilateWith(e,t=null,n=!1,o=!1,s=!1,r,i){this.pause(),this.updateRoot(e,null,null),this.services.renderer.reassimilate(t||this.groundedTree.domNode,n,o,s,r,i)}remount(e=null,t=!1,n=!0,o,s){return this.remountWith(this.services.getRootDef(!0),e,t,n,o,s)}remountWith(e,t=null,n=!1,o=!0,s,r){null==e&&(e=this.services.getRootDef(!0));const i=t&&HostRender.createVirtualItemsFor(t);this.clearRoot(!0,null,null);const d=this.settings.debugMode||void 0,a=this.services.renderer,l=a.sourceRemount=i?Object.assign(Object.assign({},i),{reused:d&&new Set,created:d&&new Set,unused:d&&new Set,readFromDOM:n,removeUnused:o,validator:s,suggester:r}):void 0;if(this.services.updateRoot(e,null,null),delete a.sourceRemount,d&&l)return{created:l.created,reused:l.reused,unused:l.unused}}readDOMString(){return HostRender.readDOMString(this.rootBoundary.treeNode)}getRootDef(){return this.services.getRootDef(!0)}getContainerElement(){return this.groundedTree.domNode}getRootElement(){return this.rootBoundary&&this.rootBoundary.treeNode.domNode}getRootElements(e){return this.rootBoundary?rootDOMTreeNodes(this.rootBoundary.treeNode,e,!1).map((e=>e.domNode)):[]}queryElement(e,t=!1){return domElementByQuery(this.groundedTree,e,!0,t)}queryElements(e,t=0,n=!1){return domElementsByQuery(this.groundedTree,e,t,!0,n)}findElements(e=0,t=!1,n){return treeNodesWithin(this.groundedTree,new Set(['dom']),e,!0,t,n).map((e=>e.domNode))}findComponents(e=0,t=!1,n){return treeNodesWithin(this.groundedTree,new Set(['boundary']),e,!0,t,n).map((e=>e.boundary&&e.boundary.component))}findTreeNodes(e,t=0,n=!1,o){const s=e?Array.isArray(e)?new Set(e):'[object Set]'===e.toString()?e:new Set(Object.keys(e)):void 0;return treeNodesWithin(this.groundedTree,s,t,!0,n,o)}modifySettings(e,t=!0){const n=this.settings.onlyRunInContainer;if(Host.modifySettings(this.settings,e),void 0!==e.onlyRunInContainer&&e.onlyRunInContainer!==n&&this.refreshRoot(!1,null,null),t)for(const t of this.shadowAPI.hosts)t!==this&&t.modifySettings(e,!1)}static modifySettings(e,t,n=!1){var o;let s=null;if(t.updateComponentModes){const e=t.updateComponentModes,n={};for(const t in e)n[t]=null!==(o=e[t])&&void 0!==o?o:(s||(s=Host.getDefaultSettings())).updateComponentModes[t];t=Object.assign(Object.assign({},t),{updateComponentModes:n})}for(const o in t)void 0!==t[o]?e[o]=t[o]:n&&(e[o]=(s||(s=Host.getDefaultSettings()))[o])}static getDefaultSettings(){return{updateTimeout:0,renderTimeout:null,updateComponentModes:{props:'shallow',state:'shallow'},preCompareDOMProps:'if-needed',wideKeysInArrays:!1,noRenderValuesMode:!1,onlyRunInContainer:!1,disableRendering:!1,duplicateDOMNodeBehaviour:'deep',duplicateDOMNodeHandler:null,duplicatableHost:!1,maxReRenders:1,renderTextTag:'',renderHTMLDefTag:'span',renderInnerHTML:null,renderTextHandler:null,renderSVGNamespaceURI:'http://www.w3.org/2000/svg',renderDOMPropsOnSwap:!0,debugMode:!1}}}Host.MIX_DOM_CLASS='Host',Host.idCount=0;const c={def:newDef,defHTML:function newDefHTML(t,n,o,s){const r={MIX_DOM_DEF:'content',tag:n||'',childDefs:[],domContent:t,domHTMLMode:!0};return n&&o&&(r.props=e.cleanDOMProps(o)),null!=s&&(r.key=s),r},Content:r,WithContent:l,ContentCopy:i,copyContent:function newContentCopyDef(e){return newContentPassDef(e,!0)},Component,Host,Ref,Fragment:PseudoFragment,Portal:PseudoPortal,Element:PseudoElement,Empty:PseudoEmpty,EmptyRemote:PseudoEmptyRemote,ref:()=>new Ref,component:createComponent,componentCtx:createComponentCtx,shadow:function createShadow(e,t,...n){const o=n[0]&&'object'==typeof n[0]?n[0]:void 0,s=(o?n[1]:n[0])||e.name||'[createShadow]',r=e.MIX_DOM_CLASS?{[s]:class extends e{}}[s]:createComponent(e,s);return prepareShadow(r,t,o),r},shadowCtx:(e,t,...n)=>{const o=n[0]&&'object'==typeof n[0]?n[0]:void 0,s=createComponentCtx(e,(o?n[1]:n[0])||e.name||'[createShadowCtx]');return prepareShadow(s,t,o),s},spread:e=>e.length>1?function(t,...n){return e(t,...n)}:e,spreadWith:e=>e.length>1?function(t,...n){return e(t,...n)}:e,remote:(e='Remote')=>{const t='WithContent',o={[e]:class extends Component{constructor(){super(...arguments),this.closure=new ContentClosure(null,this.boundary),this.Content=Object.assign(Object.assign({},newContentPassDef(this)),{contentPass:null,getRemote:()=>this}),this.ContentCopy=Object.assign(Object.assign({},newContentPassDef(this,!0)),{contentPass:null,getRemote:()=>this}),this.copyContent=e=>Object.assign(Object.assign({},newContentPassDef(null!=e?e:o,!0)),{contentPass:null,getRemote:()=>this}),this.hasContent=()=>this.closure.hasContent(),this.WithContent=(()=>{const n=this,o={[e+'[i].'+t]:class extends Component{render(){return(null!=this.props.hasContent?this.props.hasContent:n.hasContent())?r:null}}}[e+'[i].'+t];return o._WithContent=n.Content,o})()}render(){return null}static isRemote(){return!0}static addSource(e,t=e.props.order){const r=o.sources.indexOf(e),i=n.orderedIndex(t,o.sources.map((e=>e.props.order)));if(-1===r);else{if(-1===i?r===o.sources.length-1:r===i)return;o.sources.splice(r,1)}-1===i?o.sources.push(e):o.sources.splice(i,0,e);for(const t of s.passers)t.boundary.host===e.boundary.host?t.boundary.update(!0):t.boundary.host.addRefreshCall((()=>t.boundary.update(!0,null,null)),!0)}static removeSource(e){const t=o.sources.indexOf(e);if(-1===t)return null;o.sources.splice(t,1);let n=null;const r=collectInterestedInClosure(e.closure,e);n=function applyClosureEnvelope(e,t){const n=preRefreshClosure(e,t),o=n&&updatedInterestedInClosure(n),s=applyClosureRefresh(e);return o?[o[0].concat(s[0]),o[1].concat(s[1])]:s}(e.closure,null),e.closure.sourceBoundary=null;for(const t of s.passers)t.boundary.host===e.boundary.host?t.boundary.update(!0):t.boundary.host.addRefreshCall((()=>t.boundary.update(!0,null,null)),!0);return r&&e.boundary.host.addRefreshCall((()=>{for(const e of r)e.update(!0,null,null)}),!0),n}}}[e],s={[e+'.Passer']:class extends Component{constructor(e,t){super(e,t),this.constructor.passers.add(this),this.listenTo('willUnmount',(()=>this.constructor.passers.delete(this)))}render(e){return e.renderer?e.renderer(o.sources.slice()):{tag:null,MIX_DOM_DEF:'fragment',childDefs:e.wrapper?o.sources.map(((t,n)=>e.wrapper?newDefFrom(e.wrapper(t,n)):null!=e.copyKey?t.copyContent(e.copyKey):e.copy?t.ContentCopy:t.Content)).filter((e=>e)):(e.filterer?o.sources.filter(e.filterer):o.sources).map((t=>null!=e.copyKey?t.copyContent(e.copyKey):e.copy?t.ContentCopy:t.Content))}}}}[e+'.Passer'];s.passers=new Set;const i=newDef(s),d={[e+'.'+t]:class extends Component{constructor(e,t){super(e,t),this.constructor.withContents.add(this.boundary),this.listenTo('willUnmount',(()=>this.constructor.withContents.delete(this.boundary)))}render(){return(null!=this.props.hasContent?this.props.hasContent:o.hasContent())?r:null}}}[e+'.'+t];return d._WithContent=i,d.withContents=new Set,o.MIX_DOM_CLASS='Remote',o.sources=[],o.ContentPasser=s,o.Content=i,o.ContentCopy=newDef(s,{copy:!0}),o.copyContent=e=>newDef(s,{copy:!0,copyKey:e}),o.hasContent=e=>e?o.sources.some(((t,n)=>e(t,n)&&t.closure.hasContent())):o.sources.some((e=>e.closure.hasContent())),o.filterContent=(e,t)=>newDef(s,{copyKey:t,filterer:e}),o.wrapContent=(e,t)=>newDef(s,{copyKey:t,wrapper:e}),o.renderContents=e=>newDef(s,{renderer:e}),o.WithContent=d,o},wired:function createWired(...e){const t=e.length,n='string'==typeof e[t-1]?-1:0,o=e[t-3+n],s=e[t-2+n]||null,i=e[t-1+n],d=n?e[t-1]:i.name||'[createWired]',a={[d]:function(e,t){return newDef(i,Object.assign({},t.state),r)}}[d];return a.api=new ComponentWiredAPI,o&&('object'==typeof o?a.api.builtProps=o:t>2&&'function'==typeof o&&(a.api.onBuildProps=o)),s&&(a.api.onMixProps=s),a},mixin:function createMixin(e){return e},mixinComponent,mixFuncs,mixFuncsWith:function mixFuncsWith(...e){return mixFuncs(...e.filter((e=>'function'==typeof e||'string'==typeof e)),!0)},mixClassFuncs,mixClassFuncsWith:function mixClassFuncsWith(...e){return mixClassFuncs(...e.filter((e=>'function'==typeof e||'string'==typeof e)))},mixClassMixins:function mixClassMixins(...e){return mixMixins(...e)},mixClassMixinsWith:function mixClassMixinsWith(...e){return mixMixinsWith(...e)},mixMixins,mixMixinsWith,mixHOCs:function mixHOCs(e,...t){let n=e;for(const e of t)n=e(n);return e=>newDef(n,e,r)},findTreeNodesIn:(e,t,n,o,s,r)=>treeNodesWithin(e,t?Array.isArray(t)?new Set(t):'[object Set]'===t.toString()?t:new Set(Object.keys(t)):void 0,n,o,s,r),findComponentsIn:(e,t,n,o,s)=>treeNodesWithin(e,new Set(['boundary']),t,n,o,s).map((e=>e.boundary&&e.boundary.component)),findElementsIn:(e,t,n,o,s)=>treeNodesWithin(e,new Set(['dom']),t,n,o,s).map((e=>e.domNode)),queryElementIn:(e,t,n,o)=>domElementByQuery(e,t,n,o),queryElementsIn:(e,t,n,o,s)=>domElementsByQuery(e,t,n,o,s),readDOMString:(t,n=!1,o=-1,s=e.domSelfClosingTags)=>{const r=t&&(t.constructor.MIX_DOM_CLASS?t.boundary.treeNode:t.treeNode||'string'==typeof t.type&&t);return r?HostRender.readDOMString(r,n,o,s):''}};module.exports=c;
